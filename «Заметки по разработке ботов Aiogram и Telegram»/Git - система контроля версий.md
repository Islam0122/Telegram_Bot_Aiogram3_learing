Наверное, вы прекрасно знаете, что любой, уважающий себя программист, обязан пользоваться гитом. Если вы еще не начали - сейчас самое время, потому что в дальнейшем мы будем настраивать автодеплой (автоматическое развертывание и запуск) наших ботов на сервере средствами GitHub.

Я не буду сейчас углубляться в то, что такое Git - об этом полно хороших материалов в сети, если вдруг вам захочется разобраться подробнее:

Git: курс - наверное, самый лучший курс по Git на YouTube, сделанный Ильей Кантором (известным своим учебником по JavaScript - learn.javascript.ru). В коротких 50 роликах объяснение Git от А до Я.
Git. Большой практический выпуск - ролик на YouTube от Артема Матяшова с подробным объяснением зачем, почему, для чего и как
GIT - Полный Курс Git и GitHub Для Начинающих [4 ЧАСА] - еще одно большое подробное объяснение про Git и GitHub на YouTube
Git и GitHub Курс Для Новичков - ну, и чтобы было из чего выбрать - ролик от Владилена Минина. Тоже хороший вход в систему контроля версий Git.
Git для новичков - для тех, кто не любит видео, а любит статьи на Хабре
Введение в Git - хороший бесплатный курс с практикой от Хекслет
Небольшая шпаргалка по основным командам Git
Pro Git - подробная электронная книга про Git
Расскажу кратко как понимаю и как пользуюсь гитом я сам.

Если вы еще только начинающий программист, скорее всего вы программы пишете в одном файле. В смысле, не все программы в одном файле, а каждую отдельную программу в отдельном файле. И если вы пытались написать что-то немного сложнее, чем решение среднестатистической задачи на Степике, вы могли заметить, что всю логику программы хранить в одном файле не очень удобно, потому что легко запутаться и потеряться в своей собственной программе. Взрослые дяди программисты разбивают программы на отдельные файлы, каждый из которых отвечает за определенную логику работы программы. Тут у нас будут конфигурационные данные, тут исполняемый файл, тут хэндлеры для обычного пользователя, тут хэндлеры для администраторов, тут какая-то бизнес-логика и так далее, затем прокидываются связи между всеми модулями и все это работает как одно целое. Мы немного поговорим про модули и пакеты дальше и даже рассмотрим какие файловые структуры бывают у ботов, но сейчас про Git.

Когда проект расползается по множеству файлов, становится сложно держать в голове все изменения, которые в нем происходят. А любой востребованный проект не может не меняться со временем, кстати. Нельзя один раз написать код, забыть о нем и надеяться, что он будет работать всегда. Так вот, допустим, вы запустили проект, он где-то крутится на сервере и все работает, но, вдруг вы решаете, что проекту не хватает какой-нибудь крутой фичи. Вы ее имплементируете, перезапускаете проект на сервере, какое-то время все работает, но, вдруг выясняется, что не без косяков. Вам надо откатиться к предыдущей версии проекта, где еще не было новой фичи с багами.

Или представьте, что над одним большим проектом работает несколько человек. Как засинхронизировать изменения, которые делает каждый такой член команды? Да еще так засихронизировать, чтобы не поломать работу друг друга.

Для решения описанных задач, а также целого ряда других, программисты уже давно используют системы контроля версий и стандартом де-факто стал Git.

Системы контроля версий позволяют:

вернуться к любой версии кода, если вдруг что-то пошло не так или какой-то новый функционал больше не актуален;
синхронизировать совместную работу разработчиков без риска "затереть" или поломать чужой код;
посмотреть всю историю проекта - когда, кем и какие изменения были сделаны;
разрабатывать и тестировать новую версию кода, пока старая крутится на сервере.
Часто новички путают Git и GitHub. Git - это система контроля версий. То есть способ хранить дату, время, пользователя и сделанные им изменения. А GitHub - это онлайн сервис, в чем-то даже социальная сеть, в котором можно хранить свои проекты и изменения в них, вести совместную разработку, принимать предложения по изменениям в проекте, отслеживать задачи и многое другое. Но, наверное, самое главное, для чего используется GitHub - это удобный способ давать доступ к коду проекта. Кому угодно - если проект публичный и, только определенным пользователям - если проект приватный. Наверняка вы уже сталкивались с тем, что кто-то предлагает посмотреть или взять какой-либо код на гитхабе, так вот это оно самое и есть. Нужен готовый шаблон какого-то проекта - скорее всего там их уже несколько под разные требования; нужно решение какой-нибудь нетиповой задачи - с большой вероятностью, кто-нибудь ее уже решил и выложил свои наработки; хотите посмотреть примеры хорошего кода - вам на гитхаб какого-нибудь опенсорс-проекта с большим комьюнити; работаете в команде и вам надо, перед решением своей задачи, получить актуальные изменения по проекту - Github здесь как центральный сервер для синхронизации между всеми разработчиками проекта. И так далее.

Все это и еще многое другое делают Git и GitHub просто незаменимыми помощниками программиста. Поэтому, давайте начнем осваивать и активно использовать их и мы тоже. 

Как-то, когда я еще не занимался разработкой активно, я попал в компанию программистов, которые обсуждали свой проект, и вообще не понял, что происходит. Они постоянно говорили, что надо коммитить, контрибьютить, аппрувить, рефакторить, пушить, отправлять пул-реквесты, ревьюить... Вот, мы будем по-тихоньку продираться через эту терминологию и скоро вы сможете тоже разговаривать на программистском, если еще не умели :)

Коммиты
Коммиты в идеологии Git - это зафиксированные изменения. То есть, допустим, вы поработали с проектом, исправив какой-то баг - имеет смысл зафиксировать факт того, что баг был исправлен. Или вы отрефакторили громоздкую функцию, разбив ее на несколько небольших и более понятных - также имеет смысл сообщить гиту, команде и будущему себе, что рефакторинг функции выполнен. Добавили новую фичу - коммит, оптимизировали небольшой участок кода - коммит, дали старым переменным новые хорошие имена - коммит. И так далее. Если придерживаться правила, что любой логически законченный блок работы должен быть зафиксирован коммитом - и вам, и команде будет намного легче ориентироваться в коде проекта и проще находить его недостатки, если вдруг что-то идет не так.

Коммитить, в целом, не очень сложно, если не вдаваться глубоко в детали. В общем случае, при условии, что в проекте уже инициализирован Git, алгоритм такой:

Работаем над проектом и понимаем, что пора зафиксировать какое-то изменение
С помощью команды git add <имя_файла> добавляем файл в индекс
С помощью команды git commit -m "<комментарий к коммиту>" фиксируем текущее состояние
Давайте посмотрим как это работает на практике. От предыдущих уроков у нас уже осталась директория с питоновским файлом, виртуальным окружением, репозиторием Git и служебными папками. Ну, а если не осталась, хорошей практикой будет создать новый проект инициализировать в нем Git, создать виртуальное окружение и добавить модуль main.py с любым python-кодом.



Чтобы посмотреть в каком сейчас состоянии у нас файлы в проекте с точки зрения Git - нужно выполнить команду:

git status
Получим список неотслеживаемых файлов.



Git сообщает, что индекс пуст, то есть коммитить нечего, но при этом есть неотслеживаемые файлы. Тут сразу хочу обратить внимание вот на что. Смотрите, в проводнике VS Code у нас показаны 4 папки и один файл, а неотслеживаемых объектов Git показал всего три. Ну, допустим, с папкой .git понятно - нет смысла отслеживать папку, которая и так отслеживается, а почему папка .mypy_cache не попала в список неотслеживаемых файлов? Дело в том самом файле .gitignore, который был автоматически создан при установке линтера mypy. В этом можно убедиться, если зайти в папку:



Файлу .gitignore посвящен следующий шаг, просто заранее снимаю ваш вопрос, если он вдруг возник.

Итак, файлы виртуального окружения и служебные файлы VS Code отслеживать нет необходимости, нужные проекту зависимости хранят в файле requirements.txt, про который мы обязательно вспомним, когда будем разворачивать бота на удаленном сервере. Поэтому, на текущий момент у нас есть только один файл для отслеживания - это main.py. Давайте добавим его в индекс. Для этого выполним команду:

git add main.py
И снова посмотрим статус репозитория. Теперь видно, что файл main.py позеленел и его можно добавить в очередной коммит. Также есть подсказка, что если какой-либо файл нужно удалить из индекса - можно выполнить команду:

git rm --cached <файл>


Но мы пока ничего удалять не будем, а наоборот, закоммитим текущее состояние файла командой:

git commit -m "Это наш первый коммит в проекте"
Получим сообщение, типа:

(venv) Air-Mihail:Python mikhail$ git commit -m "Это наш первый коммит в проекте"
[master (корневой коммит) 17368ea] Это наш первый коммит в проекте
 1 file changed, 15 insertions(+)
 create mode 100644 main.py
И давайте сразу проверим статус Git. Сообщение будет вида:

Текущая ветка: master
Неотслеживаемые файлы:
  (используйте «git add <файл>...», чтобы добавить в то, что будет включено в коммит)
        .vscode/
        venv/

индекс пуст, но есть неотслеживаемые файлы
(используйте «git add», чтобы проиндексировать их)
Обратите внимание на число 17368ea в сообщении, которое появилось после того, как мы создали первый коммит. Это именно число, правда, в 16-ричной системе счисления. Это часть идентификатора коммита, по которому можно посмотреть что это за коммит. Если выполнить команду (не забудьте только указать номер вашего, а не моего коммита):

git show 17368ea
Можно увидеть информацию по коммиту.



Примечание 1. Если в индекс нужно добавить все неотслеживаемые и модифицированные файлы проекта, то можно пользоваться командой:

git add .
Примечание 2. Если закоммитить надо не весь индекс, а только некоторые файлы, например, чтобы разбить выполненную работу на несколько разных коммитов, можно выполнить команду:

git commit -m <файл_1> <файл_2> <файл_3> "Комментарий к коммиту"
Это также является ответом на вопрос, почему сразу нельзя коммитить из рабочей директории, зачем нужен какой-то индекс. Вот, как раз для того, чтобы иметь возможность большую проделанную работу разбить на небольшие, логически завершенные части с помощью нескольких коммитов. Впрочем, Git позволяет коммитить и минуя индекс, но это уже более продвинутая история.

Примечание 3. После добавления файлов в индекс - закоммитятся они именно в состоянии, в котором были добавлены в индекс. То есть, если вы добавили файл в индекс, а потом продолжили работать с ним - в индексе будет версия файла, которая была на момент добавления в индекс. Когда вы закоммитите файл из индекса - git status покажет, что в этом файле снова есть изменения и его опять можно добавить в индекс.

Примечание 4. Флаг -m во время коммита говорит о том, что не нужно открывать текстовый редактор для написания комментария, а можно взять его сразу из опций команды (мы его записывали в кавычках). Если этот флаг не указать, то откроется текстовый редактор, в котором нужно будет написать комментарий к коммиту.

Примечание 5. Если вы хотите добавить в индекс все изменения и сразу их закоммитить, то можно использовать не две команды git add . и git commit -m "Комментарий к коммиту", а одну, являющуюся их объединением:

git commit -am "Комментарий к коммиту"