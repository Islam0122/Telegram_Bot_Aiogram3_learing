Переменные окружения
Прежде чем поговорить о шаблоне бота, давайте разберемся с тем, где хранить секреты проекта. Под секретами будем понимать следующие данные:

API-токен бота
Пароли доступа к внешним сервисам
API-ключи
Ключи от платежных систем
...
То есть это те данные, потеря которых может повлечь за собой негативные последствия для вас или проекта.

Я уже несколько раз упоминал, что хардкодить чувствительные данные прямо в исполняемом коде - это плохая практика как с точки зрения безопасности, так и с точки зрения удобства. Небезопасно это потому, что есть не нулевая вероятность того, что когда вы захотите поделиться своим кодом - вы забудете вычистить из него чувствительные данные, и это потенциально может вам навредить. А неудобно, потому что ключи могут требоваться в разных частях программы, а где и какие - можно забыть и долго искать, в случае необходимости изменить.

Пока, в программах, что мы уже писали, API-токен бота мы хранили прямо в исполняемом файле.

BOT_TOKEN: str = '5424991242:AAGwomxQz1p46bRi_2m3V7kvJlt5RjK9xr0'
Это было исключительно в учебных целях, чтобы не усложнять повествование и сосредоточиться на тех аспектах урока, которые мы тогда разбирали. Дальше, мы так делать почти не будем, а если будем, то опять же для скорости, но с постоянным удержанием в голове мысли, что так делать неправильно.

Следующий способ хранить секреты - это завести для этого отдельный модуль, хранить все секреты в нем и импортировать их по мере необходимости. Плюс такого метода в том, что так все ключи находятся в одном месте и ими легко управлять, а минус в том, что их нельзя прокинуть из каких-то внешних сервисов администрирования, докера и т.п. Кроме того, такой файл должен храниться в репозитории как часть проекта, потому что импорты из него будут прописаны по другим модулям проекта. Конечно, из этой ситуации есть выход - можно добавить такой файл в .gitignore, но лучшим подходом считается не хранить секреты в таком файле, а загружать их в этот файл снаружи, из окружения, внутри которого проект запускается, загрузив их, перед этим, в это самое окружение. Можете думать об этом как о некоторых переменных в глобальной области видимости, но не на уровне интерпретатора, а на уровне той среды, в которой запущен интерпретатор.


.env
.env - это специальный текстовый файл, в котором мы будем хранить секреты в виде пар КЛЮЧ=ЗНАЧЕНИЕ (без пробелов) и загружать его сначала в окружение с помощью библиотеки dotenv, прямо из исполняемого питоновского скрипта. Библиотека dotenv не входит в стандартные библиотеки Python, и требует отдельной установки, с помощью уже хорошо знакомого нам менеджера пакетов pip. Установим ее.

pip install python-dotenv
Из данной библиотеки нас интересует функция load_dotenv, которая принимает в качестве аргумента путь к файлу .env (если файл лежит в той же директории, что и исполняемый python-скрипт, то можно путь не указывать) и загружает переменные из этого файла в окружение, откуда мы их уже можем получить, как это делали на предыдущем шаге, через os.getenv('<имя_переменной>'). Давайте посмотрим на примере. Пусть у нас есть два файла в одной директории. Один - это файл с секретами .env, а второй - запускаемый python-модуль main.py.

.env
BOT_TOKEN=5424991242:AAGwomxQz1p46bRi_2m3V7kvJlt5RjK9xr0
ADMIN_ID=173901673
main.py
import os

import dotenv


dotenv.load_dotenv()

print(os.getenv('BOT_TOKEN'))
print(os.getenv('ADMIN_ID'))
Если запустить main.py - получим ответ в терминале:

5424991242:AAGwomxQz1p46bRi_2m3V7kvJlt5RjK9xr0
173901673
На это мы и рассчитывали.

Важное примечание. Файл .env, если вы его храните внутри своего проекта, обязательно добавить в .gitignore, чтобы он не попал в репозиторий.

Еще примечание. Внутри проекта имеет смысл хранить файл .env.example, у которого та же структура, что и у файла .env, но вместо реальных секретов хранятся примеры того, какими секреты должны быть. Такой файл коммитится в гит и загружается в удаленный репозиторий, если вы храните код там, чтобы те люди, с кем вы хотите поделиться кодом, понимали какие данные им нужно подставить в код, чтобы и у них он работал. Соответственно, если вы добавили или удалили какие-то переменные из реального файла .env - это нужно не забывать отражать и в файле-примере .env.example.