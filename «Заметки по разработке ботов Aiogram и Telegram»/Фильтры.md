Фильтры
Давайте с вами подробнее остановимся на том, что такое фильтры, в контексте aiogram. Если упростить общую схему работы фреймворка, диспетчер получает апдейты с серверов телеграм и пытается передать их хэндлерам на обработку. У каждого хэндлера есть фильтры, через которые должен пройти апдейт, чтобы диспетчер передал его хэндлеру. Хэндлеры зарегистрированы в диспетчере в определенном порядке, и диспетчер пытается передать апдейт последовательно через фильтры каждого хэндлера. Как только апдейт проходит фильтры какого-нибудь хэндлера - этому хэндлеру апдейт и передается, а диспетчер берет следущий апдейт и начинает сначала.

Фильтр - это, по сути, функция, которая берет апдейт, что-то с ним делает и возвращает либо True, либо False. Если True - фильтр пройден, а если False, соответственно, нет.

Так как любой апдейт может содержать в себе много самой разнообразной информации, то и фильтры можно настраивать очень вариативно. Приведу лишь несколько примеров, по каким характеристикам можно фильтровать апдейты:

По наличию в сообщении команды, то есть слова, начинающегося со знака "/". Примеры: /start, /help, /settings и т.п.
По наличию определенного слова или фразы в сообщении
По id пользователя
По id чата
По id сообщения
По типу контента в апдейте (фото, видео, голосовое сообщение, анимация, стикер, документ и т.п.)
По длине текста
По состоянию, в котором находится пользователь внутри машины состояний (подробно про работу машины состояний будет в соответствующем модуле)
По времени получения апдейта
По наличию callback.data (апдейт с callback.data приходит, когда пользователь нажимает на инлайн-кнопку)
По любым сложным условиям. Например, по id пользователя, который есть в базе данных как клиент, совершивший покупок не меньше, чем на 10000 рублей в этом месяце, а по его реферальной ссылке в бот зашло не менее трех пользователей
...
Фильтры можно написать на любые события, которые доступны боту в Telegram, и для некоторых типовых случаев они уже написаны за нас. Но чтобы лучше понять как они работают в связке с хэндлерами, давайте немного попрактикуемся и напишем собственный фильтр на команду /start, добавим его в бота и проверим, что все работает как задумано. Причем, наш фильтр будет немного отличаться от того, что мы использовали ранее, когда писали Command(commands='start'). Этот фильтр, который Command(commands='start'), срабатывает на наличие команды /start в тексте, не зависимо от того, состоит текст сообщения от пользователя только из этой команды или содержит еще другие команды и слова. Для него важно только чтобы сообщение начиналось с команды /start. Вы можете легко в этом убедиться, если попробуете отправить команду /start боту в разных вариациях. Ниже привожу скриншот того, как работает хэндлер на команду /start, если ее ловить штатным фильтром Command.

Есть два способа указать тип контента в фильтре, по которому нужно апдейт отфильтровать. Либо по названию поля, прямо так и указывая в фильтре по типу контента: "text", "photo", "audio", "voice" и т.п. Либо через атрибут класса ContentType в aiogram.types.

ContentType.AUDIO == 'audio'                                # True
ContentType.TEXT == 'text'                                  # True
ContentType.PHOTO == 'photo'                                # True
ContentType.STICKER == 'sticker'                            # True
ContentType.CONTACT == 'contact'                            # True
ContentType.LOCATION == 'location'                          # True
ContentType.POLL == 'poll'                                  # True
ContentType.SUCCESSFUL_PAYMENT == 'successful_payment'      # True
ContentType.VOICE == 'voice'                                # True
ContentType.WEB_APP_DATA == 'web_app_data'                  # True

'''Фильтр CommandStart'''
Также есть отдельный фильтр конкретно на команду старт. То есть вместо фильтра Command(commands=['start']) можно использовать фильтр CommandStart() и они будут работать одинаково.

from aiogram.filters import CommandStart

#
@dp.message(CommandStart())
async def process_command_start(message: Message):
    await message.answer('Это команда /start')
